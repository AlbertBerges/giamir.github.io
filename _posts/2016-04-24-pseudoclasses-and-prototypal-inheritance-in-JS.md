---
layout: post
permalink: /pseudoclasses-and-prototypal-inheritance-in-JS
title: Pseudoclasses and prototypal inheritance in JS
path: _posts/2016-04-24-pseudoclasses-and-prototypal-inheritance-in-JS.md
time: 5
---

This is my third post in the series of "JS: Leave the classes to those other languages". If you haven’t checked out the first two posts, you can read them on [JS: Leave the classes to those other languages](/js-leave-the-classes-to-those-other-languages) and [JS Prototype chain mechanism](/js-prototype-chain-mechanism).

### Real classes (classical inheritance)

Before diving into pseudoclasses it is important to point out some characteristics of real classes (classes in Java, Ruby, etc).

{% highlight ruby %}
class Person
  attr_reader :name

  def initialize(name)
    @name = name
  end
end

class Student < Person
  attr_reader :school

  def initialize(name, school)
    super(name)
    @school = school
  end
end

giamir = Student.new('Giamir', 'TW University')

puts giamir.name # "Giamir"
puts giamir.school # "TW University"
{% endhighlight %}

In traditional languages:

* Classes are blueprints
* Objects (instances) are __copies__ of all the characteristics described by classes

Here `giamir` is an instance of `Student` and when we send to it the message `name` or `school`, `giamir` knows how to handle the message without asking or delegate to some other objects.

In JS this is not possible because __JS doesn't copy object properties__ (natively, by default).

### Pseudoclasses (prototypal inheritance)

Prototypal inheritance is the most popular way to fake classes (work with pseudoclasses) in JS.
The following code implement a pseudoclass `Person` and a pseudoclass `Student` that "inherits" from `Person`.
It's also creating an "instance" of the pseudoclass `Student` and assigned it to a variable `giamir`.

{% highlight javascript %}
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function() {
  return this.name;
};

function Student(name,school) {
  Person.call( this, name ); // pseudo-polymorphism
  this.school = school;
}

Student.prototype = Object.create(Person.prototype);

Student.prototype.getSchool = function() {
  return this.school;
};

var giamir = new Student('Giamir','TW University');

giamir.getName(); // "Giamir"
giamir.getSchool(); // "TW University"
{% endhighlight %}

Here is a mental map of the prototype chain generated by the code above.

![Pseudoclasses](http://i.imgur.com/MCkY3f4.jpg)

We create a function `Person` and a function `Student` and we want to use them as constructors. Functions in JS automatically get a property called `prototype`, which is just an empty object internally linked to `Object.prototype`.

We use explicit pseudo-polymorphism to delegate between `Student` and `Person` constructors. We call the `Person` constructor in the context of the new object we are creating using the `Student` constructor.
{% highlight javascript %}
Person.call( this, name ); // pseudo-polymorphism
{% endhighlight %}

Obviously we want the `Student.prototype` object be able to use all the `Person.prototype` methods. To do so we need to replace `Student.prototype` with a new object that delegates to `Person.prototype` instead of `Object.prototype`. The easiest way to do that is using the ES5 `Object.create()` method:
{% highlight javascript %}
Student.prototype = Object.create(Person.prototype);
{% endhighlight %}

Once that the prototype chain is in place we can create a new object `giamir` using the `Student` function as a constructor:
{% highlight javascript %}
var giamir = new Student('Giamir','TW University');
{% endhighlight %}

Here `giamir` is an object that delegates to `Student.prototype` and when we send to it the message `getSchool` for example, `giamir` has to delegate the message to the object above it in the prototype chain and so on.


### Inheritance or delegation?

The word "inheritance" has a very strong meaning with plenty of mental precedent. Merely adding "prototypal" in front to distinguish the actually nearly opposite behaviour in JS is inappropriate.

JS creates a link between two objects, where one object can essentially delegate property/function access to another object.<br> __Delegation__ is a much more accurate term for JavaScript's object-linking mechanism.

<br>

> If you’re creating constructor functions and inheriting from them, you haven’t learned JavaScript. It doesn’t matter if you’ve been doing it since 1995. You’re failing to take advantage of JavaScript’s most powerful capabilities.<br>
__You’re working in the phony version of JavaScript that only exists to dress the language up like Java.__<br><br>
-- Eric Elliott

<br>

We are ready to explore [alternative patterns in JS](/alternative-patterns-in-JS-OLOO-style) to get rid of pseudoclasses and finally embrace the nature of the language.
